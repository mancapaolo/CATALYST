<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Preprocessing with CATALYST • CATALYST</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/simplex/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Preprocessing with CATALYST">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-54095998-3"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-54095998-3');
</script>
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">CATALYST</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Release version">1.5.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Documentation</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Guides
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/differential_analysis.html">Differential analysis with CATALYST</a>
    </li>
    <li>
      <a href="../articles/preprocessing.html">Preprocessing with CATALYST</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="https://github.com/HelenaLC/CATALYST">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://www.imls.uzh.ch/en/research/robinson.html">Robinson Lab</a>
</li>
<li>
  <a href="http://www.bodenmillerlab.org">Bodenmiller Lab</a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Preprocessing with CATALYST</h1>
                        <h4 class="author">Helena L Crowell</h4>
                  <a class="author_email" href="mailto:#"></a><a href="mailto:crowellh@student.ethz.ch">crowellh@student.ethz.ch</a>
      
                              <h4 class="author">Vito RT Zanotelli</h4>
                                    <h4 class="author">Stéphane Chevrier</h4>
                                    <h4 class="author">Bernd Bodenmiller</h4>
                                    <h4 class="author">Mark D Robinson</h4>
                        
            <h4 class="date">16 May 2018</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/HelenaLC/CATALYST/blob/master/vignettes/preprocessing.Rmd"><code>vignettes/preprocessing.Rmd</code></a></small>
      <div class="hidden name"><code>preprocessing.Rmd</code></div>

    </div>

    
        <div class="abstract">
      <p class="abstract">Abstract</p>
      By addressing the limit of measurable fluorescent parameters due to instrumentation and spectral overlap, mass cytometry (CyTOF) combines heavy metal spectrometry to allow examination of up to (theoretically) 100 parameters at the single cell level. While spectral overlap is significantly less pronounced in CyTOF than flow cytometry, spillover due to detection sensitivity, isotopic impurities, and oxide formation can impede data interpretability. We designed <em><a href="http://bioconductor.org/packages/CATALYST">CATALYST</a></em> (Cytometry dATa anALYSis Tools) to provide tools for (pre)processing and analysis of cytometry data, including compensation and in particular, an improved implementation of the single-cell deconvolution algorithm.
    </div>
    

<div id="data-examples" class="section level1">
<h1 class="hasAnchor">
<a href="#data-examples" class="anchor"></a>Data examples</h1>
<ul>
<li>
<strong>Normalization:</strong><br><code>raw_data</code> is a <code>flowSet</code> with 2 experiments, each containing 2’500 raw measurements with a variation of signal over time. Samples were mixed with DVS beads captured by mass channels 140, 151, 153, 165 and 175.</li>
<li>
<strong>Debarocoding:</strong><br>
To demonstrate the debarcoding work-flow with <em><a href="http://bioconductor.org/packages/CATALYST">CATALYST</a></em>, we provide <code>sample_ff</code> which follows a 6-choose-3 barcoding scheme where mass channels 102, 104, 105, 106, 108, and 110 were used for labeling such that each of the 20 individual barcodes are positive for exactly 3 out of the 6 barcode channels. Accompanying this, <code>sample_key</code> contains a binary code of length 6 for each sample, e.g. 111000, as its unique identifier.</li>
<li>
<strong>Compensation:</strong><br>
Alongside the multiplexed-stained cell sample <code>mp_cells</code>, the package contains 36 single-antibody stained controls in <code>ss_exp</code> where beads were stained with antibodies captured by mass channels 139, 141 through 156, and 158 through 176, respectively, and pooled together. Note that, to decrease running time, we downsampled to a total of 10’000 events. Lastly, <code>isotope_list</code> contains a named list of isotopic compositions for all elements within 75 through 209 u corresponding to the CyTOF mass range at the time of writing <span class="citation">(<em>1</em>)</span>.</li>
</ul>
</div>
<div id="normalization" class="section level1">
<h1 class="hasAnchor">
<a href="#normalization" class="anchor"></a>Normalization</h1>
<p><em><a href="http://bioconductor.org/packages/CATALYST">CATALYST</a></em> provides an implementation of bead-based normalization as described by Finck et al. <span class="citation">(<em>2</em>)</span>. Here, identification of bead-singlets (used for normalization), as well as of bead-bead and cell-bead doublets (to be removed) is automated as follows:</p>
<ol style="list-style-type: decimal">
<li>beads are identified as events with their top signals in the bead channels</li>
<li>cell-bead doublets are remove by applying a separation cutoff to the distance between the lowest bead and highest non-bead signal</li>
<li>events passing all vertical gates defined by the lower bounds of bead signals are removed (these include bead-bead and bead-cell doublets)</li>
<li>bead-bead doublets are removed by applying a default <span class="math inline">\(median\;\pm5\;mad\)</span> rule to events identified in step 2. The remaining bead events are used for normalization.</li>
</ol>
<hr>
<div id="normalization-work-flow" class="section level2">
<h2 class="hasAnchor">
<a href="#normalization-work-flow" class="anchor"></a>Normalization work-flow</h2>
<div id="concatfcs-concatination-of-fcs-files" class="section level3">
<h3 class="hasAnchor">
<a href="#concatfcs-concatination-of-fcs-files" class="anchor"></a><code>concatFCS</code>: Concatination of FCS files</h3>
<p>Multiple <code>flowFrame</code>s or FCS files can be concatenated via <code>concatFCS</code>, which takes either a <code>flowSet</code>, a list of <code>flowFrame</code>s, a character specifying the location of the FCS files to be concatinated, or a vector of FCS file names as input. If <code>out_path=NULL</code> (the default), the function will return a single <code>flowFrame</code> containing the measurement data of all files. Otherwise, an FCS 3.0 standard file of the concatenated data will be written to the specified location.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(CATALYST)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw"><a href="../reference/data.html">data</a></span>(raw_data)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">ff &lt;-<span class="st"> </span><span class="kw"><a href="../reference/concatFCS.html">concatFCS</a></span>(raw_data)</a></code></pre></div>
<hr>
</div>
<div id="normcytof-normalization-using-bead-standards" class="section level3">
<h3 class="hasAnchor">
<a href="#normcytof-normalization-using-bead-standards" class="anchor"></a><code>normCytof</code>: Normalization using bead standards</h3>
<p>Since bead gating is automated here, normalization comes down to a single function that takes a <code>flowFrame</code> as input and only requires specification of the <code>beads</code> to be used for normalization. Valid options are:</p>
<ul>
<li>
<code>"dvs"</code> for bead masses 140, 151, 153, 165, 175</li>
<li>
<code>"beta"</code> for bead masses 139, 141, 159, 169, 175</li>
<li>or a custom numeric vector of bead masses</li>
</ul>
<p>By default, we apply a <span class="math inline">\(median\;\pm5\;mad\)</span> rule to remove low- and high-signal events from the bead population used for estimating normalization factors. The extent to which bead populations are trimmed can be adjusted via <code>trim</code>. The population will become increasingly narrow and bead-bead doublets will be exluded as the <code>trim</code> value decreases. Notably, slight <em>over-trimming</em> will <strong>not</strong> affect normalization. It is therefore recommended to choose a <code>trim</code> value that is small enough to assure removal of doublets at the cost of a small bead population to normalize to.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw"><a href="../reference/normCytof.html">normCytof</a></span>(<span class="dt">x=</span>ff, <span class="dt">y=</span><span class="st">"dvs"</span>, <span class="dt">k=</span><span class="dv">80</span>, <span class="dt">plot=</span><span class="ot">FALSE</span>)</a></code></pre></div>
</div>
</div>
</div>
<div id="debarcoding" class="section level1">
<h1 class="hasAnchor">
<a href="#debarcoding" class="anchor"></a>Debarcoding</h1>
<p><em><a href="http://bioconductor.org/packages/CATALYST">CATALYST</a></em> provides an implementation of the single-cell deconvolution algorithm described by Zunder et al. <span class="citation">(<em>3</em>)</span>. The package contains three functions for debarcoding and three visualizations that guide selection of thresholds and give a sense of barcode assignment quality.</p>
<p>In summary, events are assigned to a sample when i) their positive and negative barcode populations are separated by a distance larger than a threshold value and ii) the combination of their positive barcode channels appears in the barcoding scheme. Depending on the supplied scheme, there are two possible ways of arriving at preliminary event assignments:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Doublet-filtering</strong>:<br>
Given a binary barcoding scheme with a coherent number <span class="math inline">\(k\)</span> of positive channels for all IDs, the <span class="math inline">\(k\)</span> highest channels are considered positive and <span class="math inline">\(n-k\)</span> channels negative. Separation of positive and negative events equates to the difference between the <span class="math inline">\(k\)</span>th highest and <span class="math inline">\((n-k)\)</span>th lowest intensity value. If a numeric vector of masses is supplied, the barcoding scheme will be an identity matrix; the most intense channel is considered positive and its respective mass assigned as ID.<br>
</li>
<li>
<strong>Non-constant number of 1’s</strong>:<br>
Given a non-uniform number of 1’s in the binary codes, the highest separation between consecutive barcodes is looked at. In both, the doublet-filtering and the latter case, each event is assigned a binary code that, if matched with a code in the barcoding scheme supplied, dictates which row name will be assigned as ID. Cells whose positive barcodes are still very low or whose binary pattern of positive and negative barcodes doesn’t occur in the barcoding scheme will be given ID 0 for <em>“unassigned”</em>.</li>
</ol>
<p>All data required for debarcoding are held in objects of class <code>dbFrame</code> (see Appendix), allowing for the following easy-to-use work-flow:</p>
<ol style="list-style-type: decimal">
<li>as the initial step of single-cell deconcolution, <code>assignPrelim</code> will return a <code>dbFrame</code> containing the input measurement data, barcoding scheme, and preliminary event assignments.</li>
<li>assignments will be made final by <code>applyCutoffs</code>. It is recommended to estimate, and possibly adjust, population-specific separation cutoffs by running <code>estCutoffs</code> prior to this.</li>
<li>
<code>plotYields</code>, <code>plotEvents</code> and <code>plotMahal</code> aim to guide selection of devoncolution parameters and to give a sense of the resulting barcode assignment quality.</li>
<li>lastly, population-wise FCS files are written from the <code>dbFrame</code> with <code>outFCS</code>.</li>
</ol>
<hr>
<div id="debarcoding-work-flow" class="section level2">
<h2 class="hasAnchor">
<a href="#debarcoding-work-flow" class="anchor"></a>Debarcoding work-flow</h2>
<div id="assignprelim-assignment-of-preliminary-ids" class="section level3">
<h3 class="hasAnchor">
<a href="#assignprelim-assignment-of-preliminary-ids" class="anchor"></a><code>assignPrelim</code>: Assignment of preliminary IDs</h3>
<p>The debarcoding process commences by assigning each event a preliminary barcode ID. <code>assignPrelim</code> thereby takes either a binary barcoding scheme or a vector of numeric masses as input, and accordingly assigns each event the appropirate row name or mass as ID. FCS files are read into R with <code>read.FCS</code> of the <em><a href="http://bioconductor.org/packages/flowCore">flowCore</a></em> package, and are represented as an object of class <code>flowFrame</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw"><a href="../reference/data.html">data</a></span>(sample_ff)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">sample_ff</a></code></pre></div>
<pre><code>## flowFrame object 'anonymous'
## with 20000 cells and 6 observables:
##        name  desc    range   minRange maxRange
## 1 (Pd102)Di BC102 9745.799 -0.9999121 9745.799
## 2 (Pd104)Di BC104 9687.522 -0.9994696 9687.522
## 3 (Pd105)Di BC105 8924.638 -0.9989271 8924.638
## 4 (Pd106)Di BC106 8016.669 -0.9997822 8016.669
## 5 (Pd108)Di BC108 9043.869 -0.9999974 9043.869
## 6 (Pd110)Di BC110 8204.455 -0.9999368 8204.455
## 0 keywords are stored in the 'description' slot</code></pre>
<p>The debarcoding scheme should be a binary table with sample IDs as row and numeric barcode masses as column names:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw"><a href="../reference/data.html">data</a></span>(sample_key)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">head</span>(sample_key)</a></code></pre></div>
<pre><code>##    102 104 105 106 108 110
## A1   1   1   1   0   0   0
## A2   1   1   0   1   0   0
## A3   1   1   0   0   1   0
## A4   1   1   0   0   0   1
## A5   1   0   1   1   0   0
## B1   1   0   1   0   1   0</code></pre>
<p>Provided with a <code>flowFrame</code> and a compatible barcoding scheme (barcode masses must occur in the parameters of the <code>flowFrame</code>), <code>assignPrelim</code> will return a <code>dbFrame</code> containing <code>exprs</code> from the input <code>flowFrame</code>, a numeric or character vector of event assignments in slot <code>bc_ids</code>, separations between barcode populations on the normalized scale in slot <code>deltas</code>, normalized barcode intensities in slot <code>normed_bcs</code>, and the <code>counts</code> and <code>yields</code> matrices. Measurement intensities are normalized by population such that each is scaled to the 95% quantile of asinh transformed measurement intensities of events assigned to the respective barcode population.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">re0 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/assignPrelim.html">assignPrelim</a></span>(<span class="dt">x=</span>sample_ff, <span class="dt">y=</span>sample_key, <span class="dt">verbose=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">re0</a></code></pre></div>
<pre><code>## dbFrame object with
## 20000 events, 6 observables and 20 barcodes:
## 
## Current assignments:
##       0 event(s) unassigned                                                                      
## ID    A1   A2   A3   A4   A5   B1   B2   B3   B4   B5   C1   C2   C3  
## Count 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000
##                                         
## ID    C4   C5   D1   D2   D3   D4   D5  
## Count 1000 1000 1000 1000 1000 1000 1000</code></pre>
<hr>
</div>
<div id="estcutoffs-estimation-of-separation-cutoffs" class="section level3">
<h3 class="hasAnchor">
<a href="#estcutoffs-estimation-of-separation-cutoffs" class="anchor"></a><code>estCutoffs</code>: Estimation of separation cutoffs</h3>
<p>As opposed to a single global cutoff, <code>estCutoffs</code> will estimate a sample-specific cutoff to deal with barcode population cell yields that decline in an asynchronous fashion. Thus, the choice of thresholds for the distance between negative and positive barcode populations can be <em>i) automated</em> and <em>ii) independent for each barcode</em>. Nevertheless, reviewing the yield plots (see below), checking and possibly refining separation cutoffs is advisable.</p>
<p>For the estimation of cutoff parameters we consider yields upon debarcoding as a function of the applied cutoffs. Commonly, this function will be characterized by an initial weak decline, where doublets are excluded, and subsequent rapid decline in yields to zero. Inbetween, low numbers of counts with intermediate barcode separation give rise to a plateau. To facilitate robust estimation, we fit a linear and a three-parameter log-logistic function <span class="citation">(<em>4</em>)</span> to the yields function with the <code>LL.3</code> function of the <em><a href="https://CRAN.R-project.org/package=drc">drc</a></em> R package <span class="citation">(<em>5</em>)</span> (Figure @ref(fig:estCutoffs)). As an adequate cutoff estimate, we target a point that marks the end of the plateau regime and on-set of yield decline to appropriately balance confidence in barcode assignment and cell yield.</p>
<p>The goodness of the linear fit relative to the log-logistic fit is weighed as follow: <span class="math display">\[w = \frac{\text{RSS}_{log-logistic}}{\text{RSS}_{log-logistic}+\text{RSS}_{linear}}\]</span></p>
<p>The cutoffs for both functions are defined as:</p>
<p><span class="math display">\[c_{linear} = -\frac{\beta_0}{2\beta_1}\]</span> <span class="math display">\[c_{log-logistic}=\underset{x}{\arg\min}\:\frac{\vert\:f'(x)\:\vert}{f(x)} &gt; 0.1\]</span></p>
<p>The final cutoff estimate <span class="math inline">\(c\)</span> is defined as the weighted mean between these estimates:</p>
<p><span class="math display">\[c=(1-w)\cdot c_{log-logistic}+w\cdot c_{linear}\]</span></p>
<div class="figure">
<img src="estCutoffs.png" alt="(#fig:estCutoffs) Description of the automatic cutoff estimation for each individual population. The bar graphs indicate the distribution of cells relative to the barcode distance and the dotted line corresponds to the yield upon debarcoding as a function of the applied separation cutoff. This curve is fitted with a linear regression (blue line) and a three parameter log-logistic function (red line). The cutoff estimate is defined as the mean of estimates derived from both fits, weighted with the goodness of the respective fit." width="976" height="263"><p class="caption">(#fig:estCutoffs) Description of the automatic cutoff estimation for each individual population. The bar graphs indicate the distribution of cells relative to the barcode distance and the dotted line corresponds to the yield upon debarcoding as a function of the applied separation cutoff. This curve is fitted with a linear regression (blue line) and a three parameter log-logistic function (red line). The cutoff estimate is defined as the mean of estimates derived from both fits, weighted with the goodness of the respective fit.</p>
</div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co"># estimate separation cutoffs</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">re &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estCutoffs.html">estCutoffs</a></span>(<span class="dt">x=</span>re0)</a></code></pre></div>
<hr>
</div>
<div id="applycutoffs-applying-deconvolution-parameters" class="section level3">
<h3 class="hasAnchor">
<a href="#applycutoffs-applying-deconvolution-parameters" class="anchor"></a><code>applyCutoffs</code>: Applying deconvolution parameters</h3>
<p>Once preliminary assignments have been made, <code>applyCutoffs</code> will apply the deconvolution parameters: Outliers are filtered by a Mahalanobis distance threshold, which takes into account each population’s covariance, and doublets are removed by excluding events from a population if the separation between their positive and negative signals fall below a separation cutoff. These thresholds are held in the <code>sep_cutoffs</code> and <code>mhl_cutoff</code> slots of the <code>dbFrame</code>. By default, <code>applyCutoffs</code> will try to access the <code>sep_cutoffs</code> in the provided <code>dbFrame</code>, requiring having run <code>estCutoffs</code> prior to this. Alternatively, a numeric vector of cutoff values or a single, global value may be specified. In either case, it is highly recommended to thoroughly review the yields plot (see above), as the choice of separation cutoffs will determine debarcoding quality and cell yield.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># use global separation cutoff</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw"><a href="../reference/applyCutoffs.html">applyCutoffs</a></span>(<span class="dt">x=</span>re, <span class="dt">sep_cutoffs=</span><span class="fl">0.35</span>)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co"># use population-specific cutoffs</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">re &lt;-<span class="st"> </span><span class="kw"><a href="../reference/applyCutoffs.html">applyCutoffs</a></span>(<span class="dt">x=</span>re)</a></code></pre></div>
<hr>
</div>
<div id="outfcs-output-population-wise-fcs-files" class="section level3">
<h3 class="hasAnchor">
<a href="#outfcs-output-population-wise-fcs-files" class="anchor"></a><code>outFCS</code>: Output population-wise FCS files</h3>
<p>Once event assignments have been finalized, a separate FCS file can be written for each population by running <code>outFCS</code>. If option <code>out_nms=NULL</code> (the default), the respective population`s ID in the barcoding scheme will be used as file name. Alternatively, an ordered character vector or a 2 column CSV with sample IDs and the desired file names may be specified as a naming scheme.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw"><a href="../reference/outFCS.html">outFCS</a></span>(<span class="dt">x=</span>re, <span class="dt">y=</span>sample_ff)</a></code></pre></div>
<hr>
</div>
<div id="plotyields-selecting-barcode-separation-cutoffs" class="section level3">
<h3 class="hasAnchor">
<a href="#plotyields-selecting-barcode-separation-cutoffs" class="anchor"></a><code>plotYields</code>: Selecting barcode separation cutoffs</h3>
<p>For each barcode, <code>plotYields</code> will show the distribution of barcode separations and yields upon debarcoding as a function of separation cutoffs. If available, the currently used separation cutoff as well as its resulting yield within the population is indicated in the plot’s main title.</p>
<p>Option <code>which=0</code> will render a summary plot of all barcodes. Here, the overall yield achieved by applying the current set of cutoff values will be shown. All yield functions should behave as described above: decline, stagnation, decline. Convergence to 0 yield at low cutoffs is a strong indicator that staining in this channel did not work, and excluding the channel entirely is sensible in this case. It is thus recommended to <strong>always</strong> view the all-barcodes yield plot to eliminate uninformative populations, since small populations may cause difficulties when computing spill estimates.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw"><a href="../reference/plotYields.html">plotYields</a></span>(<span class="dt">x=</span>re, <span class="dt">which=</span><span class="kw">c</span>(<span class="st">"C1"</span>, <span class="dv">0</span>), <span class="dt">plotly=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<p><img src="preprocessing_files/figure-html/unnamed-chunk-10-1.png" width="768"><img src="preprocessing_files/figure-html/unnamed-chunk-10-2.png" width="768"></p>
<hr>
</div>
<div id="plotevents-normalized-intensities" class="section level3">
<h3 class="hasAnchor">
<a href="#plotevents-normalized-intensities" class="anchor"></a><code>plotEvents</code>: Normalized intensities</h3>
<p>Normalized intensities for a barcode can be viewed with <code>plotEvents</code>. Here, each event corresponds to the intensities plotted on a vertical line at a given point along the x-axis. Option <code>which=0</code> will display unassigned events, and the number of events shown for a given sample may be varied via <code>n_events</code>. If <code>which="all"</code>, the function will render an event plot for all IDs (including 0) with events assigned.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co"># event plots for unassigned events</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co"># &amp; barcode population D1</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="kw"><a href="../reference/plotEvents.html">plotEvents</a></span>(<span class="dt">x=</span>re, <span class="dt">which=</span><span class="kw">c</span>(<span class="dv">0</span>, <span class="st">"D1"</span>), <span class="dt">n_events=</span><span class="dv">25</span>)</a></code></pre></div>
<p><img src="preprocessing_files/figure-html/unnamed-chunk-11-1.png" width="768"><img src="preprocessing_files/figure-html/unnamed-chunk-11-2.png" width="768"></p>
<hr>
</div>
<div id="plotmahal-all-barcode-biaxial-plot" class="section level3">
<h3 class="hasAnchor">
<a href="#plotmahal-all-barcode-biaxial-plot" class="anchor"></a><code>plotMahal</code>: All barcode biaxial plot</h3>
<p>Function <code>plotMahal</code> will plot all inter-barcode interactions for the population specified with argument <code>which</code>. Events are colored by their Mahalanobis distance. <span style="color:firebrick"><em>NOTE: For more than 7 barcodes (up to 128 samples) the function will render an error, as this visualization is infeasible and hardly informative. Using the default Mahalanobis cutoff value of 30 is recommended in such cases.</em></span></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw"><a href="../reference/plotMahal.html">plotMahal</a></span>(<span class="dt">x=</span>re, <span class="dt">which=</span><span class="st">"B3"</span>)</a></code></pre></div>
<p><img src="preprocessing_files/figure-html/unnamed-chunk-12-1.png" width="576"></p>
</div>
</div>
</div>
<div id="compensation" class="section level1">
<h1 class="hasAnchor">
<a href="#compensation" class="anchor"></a>Compensation</h1>
<p><em><a href="http://bioconductor.org/packages/CATALYST">CATALYST</a></em> performs compensation via a two-step approach comprising:</p>
<ol style="list-style-type: lower-roman">
<li>identification of single positive populations via single-cell debarcoding (SCD) of single-stained beads (or cells)</li>
<li>estimation of a spillover matrix (SM) from the populations identified, followed by compensation via multiplication of measurement intensities by its inverse, the compensation matrix (CM).</li>
</ol>
<p><strong><em>Retrieval of real signal.</em></strong> As in conventional flow cytometry, we can model spillover linearly, with the channel stained for as predictor, and spill-effected channels as response. Thus, the intensity observed in a given channel <span class="math inline">\(j\)</span> are a linear combination of its real signal and contributions of other channels that spill into it. Let <span class="math inline">\(s_{ij}\)</span> denote the proportion of channel <span class="math inline">\(j\)</span> signal that is due to channel <span class="math inline">\(i\)</span>, and <span class="math inline">\(w_j\)</span> the set of channels that spill into channel <span class="math inline">\(j\)</span>. Then</p>
<p><span class="math display">\[I_{j, observed}\; = I_{j, real} + \sum_{i\in w_j}{s_{ij}}\]</span></p>
<p>In matrix notation, measurement intensities may be viewed as the convolution of real intensities and a spillover matrix with dimensions number of events times number of measurement parameters:</p>
<p><span class="math display">\[I_{observed}\; = I_{real} \cdot SM\]</span></p>
<p>Therefore, we can estimate the real signal, <span class="math inline">\(I_{real}\;\)</span>, as:</p>
<p><span class="math display">\[I_{real} = I_{observed}\; \cdot {SM}^{-1} = I_{observed}\; \cdot CM\]</span> where <span class="math inline">\(\text{SM}^{-1}\)</span> is termed compensation matrix (<span class="math inline">\(\text{CM}\)</span>). This approach is implemented in <code><a href="../reference/compCytof.html">compCytof(..., method = "flow")</a></code> and makes use of <em><a href="http://bioconductor.org/packages/flowCore">flowCore</a></em>’s <code>compensate</code> function.</p>
<p>While mathematically exact, the solution to this equation will yield negative values, and does not account for the fact that real signal would be strictly non-negative counts. A computationally efficient way to adress this is the use of non-negative linear least squares (NNLS):</p>
<p><span class="math display">\[\min \: \{ \: ( I_{observed} - SM \cdot I_{real} ) ^ T \cdot ( I_{observed} - SM \cdot I_{real} ) \: \} \quad \text{s.t.} \: I_{real} ≥ 0\]</span></p>
<p>This approach will solve for <span class="math inline">\(I_{real}\)</span> such that the least squares criterion is optimized under the constraint of non-negativity. To arrive at such a solution we apply the Lawson-Hanson algorithm <span class="citation">(<em>6</em>, <em>7</em>)</span> for NNLS implemented in the <em>nnls</em> R package (<code>method="nnls"</code>).</p>
<p><strong><em>Estimation of SM.</em></strong> Because any signal not in a single stain experiment’s primary channel <span class="math inline">\(j\)</span> results from channel crosstalk, each spill entry <span class="math inline">\(s_{ij}\)</span> can be approximated by the slope of a linear regression with channel <span class="math inline">\(j\)</span> signal as the response, and channel <span class="math inline">\(i\)</span> signals as the predictors, where <span class="math inline">\(i\in w_j\)</span>. <code><a href="../reference/computeSpillmat.html">computeSpillmat()</a></code> offers two alternative ways for spillover estimation, summarized in Figure @ref(fig:methods).</p>
<p>The <code>default</code> method approximates this slope with the following single-cell derived estimate: Let <span class="math inline">\(i^+\)</span> denote the set of cells that are possitive in channel <span class="math inline">\(i\)</span>, and <span class="math inline">\(s_{ij}^c\)</span> be the channel <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> spill computed for a cell <span class="math inline">\(c\)</span> that has been assigned to this population. We approximate <span class="math inline">\(s_{ij}^c\)</span> as the ratio between the signal in unstained spillover receiving and stained spillover emitting channel, <span class="math inline">\(I_j\)</span> and <span class="math inline">\(I_i\)</span>, respectively. The expected background in these channels, <span class="math inline">\(m_j^-\)</span> and <span class="math inline">\(m_i^-\)</span>, is computed as the median signal of events that are i) negative in the channels for which spill is estimated (<span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>); ii) not assigned to potentionally interacting channels; and, iii) not unassigned, and subtracted from all measurements:</p>
<p><span class="math display">\[s_{ij}^c = \frac{I_j - m_j^{i-}}{I_i - m_i^{i-}}\]</span></p>
<p>Each entry <span class="math inline">\(s_{ij}\)</span> in <span class="math inline">\(\text{SM}\)</span> is then computed as the median spillover across all cells <span class="math inline">\(c\in i^+\)</span>:</p>
<p><span class="math display">\[s_{ij} = \text{med}(s_{ij}^c\:|\:c\in i^+)\]</span></p>
<p>In a population-based fashion, as done in conventional flow cytometry, <code>method = "classic"</code> calculates <span class="math inline">\(s_{ij}\)</span> as the slope of a line through the medians (or trimmed means) of stained and unstained populations, <span class="math inline">\(m_j^+\)</span> and <span class="math inline">\(m_i^+\)</span>, respectively. Background signal is computed as above and substracted, according to:</p>
<p><span class="math display">\[s_{ij} = \frac{m_j^+-m_j^-}{m_i^+-m_i^-}\]</span></p>
<div class="figure">
<img src="methods.png" alt="(#fig:methods) Population versus single-cell based spillover estimation." width="800" height="360"><p class="caption">(#fig:methods) Population versus single-cell based spillover estimation.</p>
</div>
<p>On the basis of their additive nature, spill values are estimated independently for every pair of interacting channels. <code>interactions = "default"</code> thereby exclusively takes into account interactions that are sensible from a chemical and physical point of view:</p>
<ul>
<li>
<span class="math inline">\(M\pm1\)</span> channels (<em>abundance sensitivity</em>)</li>
<li>the <span class="math inline">\(M+16\)</span> channel (<em>oxide formation</em>)</li>
<li>channels measuring isotopes (<em>isotopic impurities</em>)</li>
</ul>
<p>See Table @ref(tab:isotopes) for the list of mass channels considered to potentionally contain isotopic contaminatons, along with a heat map representation of all interactions considered by the <code>default</code> method in Figure @ref(fig:interactions).</p>
<table class="table">
<thead><tr class="header">
<th>Metal</th>
<th>Isotope masses</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>La</td>
<td>138, 139</td>
</tr>
<tr class="even">
<td>Pr</td>
<td>141</td>
</tr>
<tr class="odd">
<td>Nd</td>
<td>142, 143, 144, 145, 146, 148, 150</td>
</tr>
<tr class="even">
<td>Sm</td>
<td>144, 147, 148, 149, 150, 152, 154</td>
</tr>
<tr class="odd">
<td>Eu</td>
<td>151, 153</td>
</tr>
<tr class="even">
<td>Gd</td>
<td>152, 154, 155, 156, 157, 158, 160</td>
</tr>
<tr class="odd">
<td>Dy</td>
<td>156, 158, 160, 161, 162, 163, 164</td>
</tr>
<tr class="even">
<td>Er</td>
<td>162, 164, 166, 167, 168, 170</td>
</tr>
<tr class="odd">
<td>Tb</td>
<td>159</td>
</tr>
<tr class="even">
<td>Ho</td>
<td>165</td>
</tr>
<tr class="odd">
<td>Yb</td>
<td>168, 170, 171, 172, 173, 174, 176</td>
</tr>
<tr class="even">
<td>Tm</td>
<td>169</td>
</tr>
<tr class="odd">
<td>Lu</td>
<td>175, 176</td>
</tr>
</tbody>
</table>
<p>:(#tab:isotopes) List of isotopes available for each metal used in CyTOF. In addition to <span class="math inline">\(M\pm1\)</span> and <span class="math inline">\(M+16\)</span> channels, these mass channels are considered during estimation of spill to capture channel crosstalk that is due to isotopic contanimations <span class="citation">(<em>1</em>)</span>.</p>
<div class="figure">
<img src="interactions.png" alt="(#fig:interactions) Heat map of spill expected interactions. These are considered by the default method of computeSpillmat." width="590" height="600"><p class="caption">(#fig:interactions) Heat map of spill expected interactions. These are considered by the default method of computeSpillmat.</p>
</div>
<p>Alternatively, <code>interactions = "all"</code> will compute a spill estimate for all <span class="math inline">\(n\cdot(n-1)\)</span> possible interactions, where <span class="math inline">\(n\)</span> denotes the number of measurement parameters. Estimates falling below the threshold specified by <code>th</code> will be set to zero. Lastly, note that diagonal entries <span class="math inline">\(s_{ii} = 1\)</span> for all <span class="math inline">\(i\in 1, ..., n\)</span>, so that spill is relative to the total signal measured in a given channel.</p>
<hr>
<div id="compensation-work-flow" class="section level2">
<h2 class="hasAnchor">
<a href="#compensation-work-flow" class="anchor"></a>Compensation work-flow</h2>
<div id="computespillmat-estimation-of-the-spillover-matrix" class="section level3">
<h3 class="hasAnchor">
<a href="#computespillmat-estimation-of-the-spillover-matrix" class="anchor"></a><code>computeSpillmat</code>: Estimation of the spillover matrix</h3>
<p>Given a flowFrame of single-stained beads (or cells) and a numeric vector specifying the masses stained for, <code>computeSpillmat</code> estimates the spillover matrix as described above. Spill values are affected my the <code>method</code> chosen for their estimation, that is <code>"median"</code> or <code>"mean"</code>, and, in the latter case, the specified <code>trim</code> percentage. The process of adjusting these options and reviewing the compensated data may iterative until compensation is satisfactory</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co"># get single-stained control samples</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw"><a href="../reference/data.html">data</a></span>(ss_exp)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co"># specify mass channels stained for</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">bc_ms &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">139</span>, <span class="dv">141</span><span class="op">:</span><span class="dv">156</span>, <span class="dv">158</span><span class="op">:</span><span class="dv">176</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co"># debarcode</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">re &lt;-<span class="st"> </span><span class="kw"><a href="../reference/assignPrelim.html">assignPrelim</a></span>(<span class="dt">x=</span>ss_exp, <span class="dt">y=</span>bc_ms, <span class="dt">verbose=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">re &lt;-<span class="st"> </span><span class="kw"><a href="../reference/estCutoffs.html">estCutoffs</a></span>(<span class="dt">x=</span>re)</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">re &lt;-<span class="st"> </span><span class="kw"><a href="../reference/applyCutoffs.html">applyCutoffs</a></span>(<span class="dt">x=</span>re)</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="co"># compute spillover matrix</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">spillMat &lt;-<span class="st"> </span><span class="kw"><a href="../reference/computeSpillmat.html">computeSpillmat</a></span>(<span class="dt">x=</span>re)</a></code></pre></div>
<hr>
</div>
<div id="plotspillmat-spillover-matrix-heat-map" class="section level3">
<h3 class="hasAnchor">
<a href="#plotspillmat-spillover-matrix-heat-map" class="anchor"></a><code>plotSpillmat</code>: Spillover matrix heat map</h3>
<p><code>plotSpillmat</code> provides a visualization of estimated spill percentages as a heat map. Channels without a single-antibody stained control are annotated in grey, and colours are ramped to the highest spillover value present. Option <code>annotate=TRUE</code> (the default) will display spill values inside each bin, and the total amount of spill caused and received by each channel on the top and to the right, respectively.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw"><a href="../reference/plotSpillmat.html">plotSpillmat</a></span>(<span class="dt">bc_ms=</span>bc_ms, <span class="dt">SM=</span>spillMat, <span class="dt">plotly=</span><span class="ot">FALSE</span>) </a></code></pre></div>
<p><img src="preprocessing_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<hr>
</div>
<div id="compcytof-compensation-of-mass-cytometry-data" class="section level3">
<h3 class="hasAnchor">
<a href="#compcytof-compensation-of-mass-cytometry-data" class="anchor"></a><code>compCytof</code>: Compensation of mass cytometry data</h3>
<p>Assuming a linear spillover, <code>compCytof</code> compensates mass spectrometry based experiments using a provided spillover matrix. If the spillover matrix (SM) does not contain the same set of columns as the input experiment, it will be adapted according to the following rules:</p>
<ol style="list-style-type: decimal">
<li>columns present in the SM but not in the input data will be removed from it</li>
<li>non-metal columns present in the input but not in the SM will be added such that they do neither receive nor cause spill</li>
<li>metal columns that have the same mass as a channel present in the SM will receive (but not emit) spillover according to that channel</li>
<li>if an added channel could potentially receive spillover (as it has +/-1M or +16M of, or is of the same metal type as another channel measured), a warning will be issued as there could be spillover interactions that have been missed and may lead to faulty compensation</li>
</ol>
<p>If <code>out_path=NULL</code> (the default), the function will return a <code>flowFrame</code> of the compensated data. Else, compensated data will be written to the specified location as FCS 3.0 standard files. Multiple data sets may be corrected based on the same spill estimates if the input <code>x</code> is a character string specifying the location of the FCS files to be compensated.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw"><a href="../reference/data.html">data</a></span>(mp_cells)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">comped_flow &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compCytof.html">compCytof</a></span>(<span class="dt">x=</span>mp_cells, <span class="dt">y=</span>spillMat, <span class="dt">method=</span><span class="st">"flow"</span>)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">comped_nnls &lt;-<span class="st"> </span><span class="kw"><a href="../reference/compCytof.html">compCytof</a></span>(<span class="dt">x=</span>mp_cells, <span class="dt">y=</span>spillMat, <span class="dt">method=</span><span class="st">"nnls"</span>)</a></code></pre></div>
<p><img src="preprocessing_files/figure-html/unnamed-chunk-17-1.png" width="825.6"></p>
</div>
</div>
</div>
<div id="appendix" class="section level1">
<h1 class="hasAnchor">
<a href="#appendix" class="anchor"></a>Appendix</h1>
<div id="the-dbframe-class" class="section level2">
<h2 class="hasAnchor">
<a href="#the-dbframe-class" class="anchor"></a>The <code>dbFrame</code> class</h2>
<p>Data returned by and used throughout debarcoding are stored in a debarcoding frame. An object of class <code>dbFrame</code> includes the following elements:</p>
<ul>
<li>Event information, stored in a matrix, is passed from the input <code>flowFrame</code> specified in <code>assignPrelim</code> to the <code>exprs</code> slot.</li>
<li>The <code>bc_key</code> slot is a binary matrix with numeric masses as column names and sample names as row names. If supplied with a numeric vector of masses, <code>assignPrelim</code> will internally generate a concurrent representation.</li>
<li>
<code>bc_ids</code> is a numeric or character vector of the ID assignments that have been made. If a given event’s separation falls below its separation cutoff, or above the population’s Mahalanobis distance cutoff, it will be give ID 0 for <em>“unassigned”</em>. Assignments can be manipulated with <code>bc_ids&lt;-</code>.</li>
<li>The <code>deltas</code> slot contains for each event the separations between positive and nergative populations, that is, between the lowest positive and highest negative intesity.</li>
<li>
<code>normed_bcs</code> are the barcode intensities normalized by population. Here, each event is scaled to the 95% quantile of the population it’s been assigned to. <code>sep_cutoffs</code> are applied to these normalized intensities.</li>
<li>Slots <code>sep_cutoffs</code> and <code>mhl_cutoff</code> contain the devoncolution parameters. These can be specified by standard replacement via <code>sep_cutoffs&lt;-</code> and <code>mhl_cutoff&lt;-</code>.</li>
<li>
<code>counts</code> and <code>yields</code> are matrices of dimension (# samples)x(101). Each row in the <code>counts</code> matrix contains the number of events within a sample for which positive and negative populations are separated by a distance between in [0,0.01), …, [0.99,1], respectively. The percentage of events within a sample that will be obtained after applying a separation cutoff of 0, 0.01, …, 1, respectively, is given in <code>yields</code>.</li>
</ul>
<p>For a brief overview, <code>show(dbFrame)</code> will display</p>
<ul>
<li>the dimensionality of the measurement data and number of barcodes</li>
<li>current assignments in order of decreasing population size</li>
<li>current separation cutoffs (if available)</li>
<li>the average and per-population yield achieved upon debarcoding<br>
(if <code>sep_cutoffs</code> are specified)</li>
</ul>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-isotopes">
<p>1. J. S. Coursey, D. J. Schwab, J. J. Tsai, R. A. Dragoset, Atomic weights and isotopic compositions (2015), (available at <a href="http://physics.nist.gov/Comp" class="uri">http://physics.nist.gov/Comp</a>).</p>
</div>
<div id="ref-Finck13">
<p>2. R. Finck <em>et al.</em>, Normalization of mass cytometry data with bead standards. <em>Cytometry Part A</em>. <strong>83A</strong>, 483–494 (2013).</p>
</div>
<div id="ref-Zunder15">
<p>3. E. R. Zunder <em>et al.</em>, Palladium-based mass tag cell barcoding with a doublet-filtering scheme and single-cell deconvolution algorithm. <em>Nat. Protocols</em>. <strong>10</strong>, 316–333 (2015).</p>
</div>
<div id="ref-Finney">
<p>4. D. J. Finney, Probit analysis, 3rd ed. <em>Journal of Pharmaceutical Sciences</em>. <strong>60</strong>, 1432–1432 (1971).</p>
</div>
<div id="ref-drc">
<p>5. C. Ritz, F. Baty, J. C. Streibig, D. Gerhard, Dose-response analysis using r. <em>PLOS ONE</em>. <strong>10</strong> (2015).</p>
</div>
<div id="ref-nnls1">
<p>6. C. Lawson, R. Hanson, <em>Solving least squares problems</em> (Prentice Hall, Englewood Cliffs, NJ, 1974).</p>
</div>
<div id="ref-nnls2">
<p>7. C. Lawson, R. Hanson, <em>Solving least squares problems</em> (Classics in Applied Mathematics, SIAM, Philadelphia, 1995).</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#data-examples">Data examples</a></li>
      <li>
<a href="#normalization">Normalization</a><ul class="nav nav-pills nav-stacked">
<li><a href="#normalization-work-flow">Normalization work-flow</a></li>
      </ul>
</li>
      <li>
<a href="#debarcoding">Debarcoding</a><ul class="nav nav-pills nav-stacked">
<li><a href="#debarcoding-work-flow">Debarcoding work-flow</a></li>
      </ul>
</li>
      <li>
<a href="#compensation">Compensation</a><ul class="nav nav-pills nav-stacked">
<li><a href="#compensation-work-flow">Compensation work-flow</a></li>
      </ul>
</li>
      <li>
<a href="#appendix">Appendix</a><ul class="nav nav-pills nav-stacked">
<li><a href="#the-dbframe-class">The <code>dbFrame</code> class</a></li>
      </ul>
</li>
      <li><a href="#references">References</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Helena L. Crowell, Vito R.T. Zanotelli, Stéphane Chevrier, Mark D. Robinson, Bernd Bodenmiller.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
